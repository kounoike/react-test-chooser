{"version":3,"sources":["CountUpCanvas.tsx","MainSelector.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["CountUpCanvas","bgColor","interval","useState","count","setCount","ctxRef","useRef","canvasRef","useCallback","node","current","getContext","useEffect","ctx","save","fillStyle","fillRect","restore","font","textBaseline","fillText","drawToCanvas","callback","delay","savedCallback","id","setInterval","clearInterval","useInterval","ref","width","height","MountToOffScreen","elem","children","ReactDOM","createPortal","MainSelector","mainRef","isMain","document","createElement","appendChild","style","backgroundColor","position","transform","transformOrigin","MainDiv","React","forwardRef","App","countUps","setCountUps","mainIndex","setMainIndex","countUpComponents","map","cup","idx","onClick","console","log","countUpsCopy","slice","setCountUpMain","key","display","flexDirection","margin","prev","hue","length","Math","random","flex","Boolean","window","location","hostname","match","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.ef76101b.chunk.js","sourcesContent":["import React, { useCallback, useEffect, useRef, useState } from 'react'\r\n\r\nfunction useInterval(callback: (...args: any[]) => void, delay: number) {\r\n    const savedCallback = useRef<(...args: any[]) => void>(()=>{});\r\n  \r\n    // Remember the latest callback.\r\n    useEffect(() => {\r\n      savedCallback.current = callback;\r\n    }, [callback]);\r\n  \r\n    // Set up the interval.\r\n    useEffect(() => {\r\n      function tick() {\r\n        if (savedCallback)\r\n            savedCallback.current();\r\n      }\r\n      if (delay !== null) {\r\n        let id = setInterval(tick, delay);\r\n        return () => clearInterval(id);\r\n      }\r\n    }, [delay]);\r\n}\r\n\r\ntype Props = {\r\n    bgColor: string,\r\n    interval: number\r\n}\r\n\r\nfunction drawToCanvas(ctx: CanvasRenderingContext2D|undefined, count: number, bgColor: string): void {\r\n    if (ctx) {\r\n        ctx.save()\r\n        ctx.fillStyle = bgColor\r\n        ctx.fillRect(0, 0, 400, 300)\r\n        ctx.restore()\r\n        ctx.save()\r\n        ctx.fillStyle = bgColor\r\n        ctx.fillRect(0, 0, 400, 300)\r\n        ctx.restore()\r\n        ctx.save()\r\n        ctx.font = '100pt Arial'\r\n        ctx.fillStyle = 'rgb(255, 255, 255)'\r\n        ctx.textBaseline = 'top'\r\n        ctx.fillText(`${count}`, 30, 30)\r\n        ctx.restore()\r\n    }\r\n}\r\n\r\nconst CountUpCanvas: React.FC<Props> = ({bgColor, interval}) => {\r\n    const [count, setCount] = useState(0)\r\n    const ctxRef = useRef<CanvasRenderingContext2D>()\r\n    const canvasRef = useCallback(node => {\r\n        if (node !== null) {\r\n            ctxRef.current = (node as any).getContext('2d')\r\n        }\r\n    }, [])\r\n    useEffect(() => drawToCanvas(ctxRef.current, count, bgColor), [ctxRef, count, bgColor])\r\n    useInterval(() => setCount(count + 1), interval)\r\n    return (\r\n        <canvas ref={canvasRef} width=\"400\" height=\"300\"></canvas>\r\n    )\r\n}\r\n\r\nexport default CountUpCanvas","import React, { useEffect, useRef } from 'react'\r\nimport ReactDOM from 'react-dom';\r\n\r\nconst MountToOffScreen: React.FC<{elem: HTMLElement}> = ({elem, children})  => {\r\n    return ReactDOM.createPortal(children, elem)\r\n}\r\n\r\ntype Props = {\r\n    mainRef: React.RefObject<HTMLDivElement>,\r\n    isMain: boolean\r\n}\r\n\r\nconst MainSelector: React.FC<Props> = ({mainRef, isMain, children}) => {\r\n    const elem = useRef(document.createElement('div'))\r\n    const ref = useRef<any>(null)\r\n    useEffect(() => {\r\n        if(isMain) {\r\n            mainRef.current?.appendChild(elem.current)\r\n        } else {\r\n            ref.current?.appendChild(elem.current)\r\n        }\r\n    }, [mainRef, isMain, elem])\r\n\r\n    return (\r\n        <div style={{width: \"200px\", height: \"150px\", backgroundColor: \"#cccccc\", position: \"relative\"}}>\r\n            <div style={{position: \"absolute\"}}>\r\n                Current selected item\r\n            </div>\r\n            <div ref={ref} style={{transform: \"scale(0.5)\", transformOrigin: \"0 0\", position: \"absolute\"}}>\r\n                <MountToOffScreen elem={elem.current}>{children}</MountToOffScreen>\r\n            </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default MainSelector\r\n","import React, { useRef, useState } from 'react';\nimport './App.css';\nimport CountUpCanvas from './CountUpCanvas';\nimport MainSelector from './MainSelector';\n\nconst MainDiv = React.forwardRef((({ children }, ref) => (\n    <div ref={ref}>{children}</div>\n)) as React.ForwardRefRenderFunction<HTMLDivElement, { children?: React.ReactNode }>)\n\ntype CountUpData = {\n    isMain: boolean,\n    interval: number,\n    bgColor: string\n}\n\nfunction App() {\n  const ref = useRef<HTMLDivElement>(null)\n\n  const [countUps, setCountUps] = useState<CountUpData[]>([\n    {\n      interval: 500,\n      bgColor: \"red\",\n      isMain: true\n    },\n    {\n      interval: 1000,\n      bgColor: \"green\",\n      isMain: false\n    },\n    {\n      interval: 2000,\n      bgColor: \"blue\",\n      isMain: false\n    }\n  ])\n  let [mainIndex, setMainIndex] = useState(0)\n  const setCountUpMain = (idx: number) => {\n    console.log(idx, countUps)\n    const countUpsCopy = countUps.slice()\n    countUpsCopy[mainIndex].isMain = false\n    countUpsCopy[idx].isMain = true\n    setCountUps(countUpsCopy)\n    setMainIndex(idx)\n  }\n  const addCountUp = () => {\n    setCountUps((prev => {\n      const hue = (prev.length * 20) % 360\n      const interval = Math.random() * 3000 + 100\n      return [...prev, { interval: interval, bgColor: `hsl(${hue}, 100%, 50%)`, isMain: false }]\n    }))\n  }\n  const countUpComponents = countUps.map((cup, idx) => (\n    <div onClick={() => setCountUpMain(idx)} key={idx}>\n      <MainSelector mainRef={ref} isMain={cup.isMain}>\n        <CountUpCanvas bgColor={cup.bgColor} interval={cup.interval}></CountUpCanvas>\n      </MainSelector>\n    </div>\n  ))\n\n\n  return (\n    <div style={{ display: \"flex\", flexDirection: \"column\" }}>\n      <div style={{ height: \"30px\", margin: \"10px 10px\" }}>\n        <button onClick={addCountUp}>Add</button>\n      </div>\n      <div style={{ display: \"flex\", flex: 1 }}>\n        <div id=\"main\" style={{ flex: 1, backgroundColor: \"#333333\" }}>\n          <MainDiv ref={ref}></MainDiv>\n        </div>\n        <div id=\"sub\" style={{ width: \"200px\" }}>\n          {countUpComponents}\n        </div>\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}